# -*- coding: utf-8 -*-
"""_KNN_scratch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18LbVsqnEdz1IG6qdS504ykr1_f9Dsu8Z
"""

import numpy as np
from collections import Counter

# Redefine the KNN_Classifier class to correct the distance metric handling
class KNN_Classifier:
    def __init__(self, k=5, distance_metric='euclidean'):
        self.k = k
        self.distance_metric = distance_metric

    def _euclidean_distance(self, x1, x2):
        return np.sqrt(np.sum((x1 - x2)**2))

    def _manhattan_distance(self, x1, x2):
        return np.sum(np.abs(x1 - x2))

    # This method will return the appropriate distance function based on the metric name
    def _get_distance_function(self):
        if self.distance_metric == 'euclidean':
            return self._euclidean_distance
        elif self.distance_metric == 'manhattan':
            return self._manhattan_distance
        else:
            raise ValueError(f"Unsupported distance metric: {self.distance_metric}")

    def nearest_neighbors(self, X_train, single_test_data_point):
        distances = []
        distance_func = self._get_distance_function() # Get the actual distance function

        for i, train_data_point in enumerate(X_train):
            dist = distance_func(train_data_point, single_test_data_point)
            distances.append((dist, i)) # Store (distance, index)

        # Sort by distance and get indices of the k nearest neighbors
        distances.sort(key=lambda x: x[0])
        return [idx for dist, idx in distances[:self.k]]

    def predict(self, X_train, Y_train, X_test):
        predictions = []
        for x_test_point in X_test:
            # Find k nearest neighbors for the current test point
            neighbor_indices = self.nearest_neighbors(X_train, x_test_point)

            # Get the labels of these neighbors
            # Handle both numpy arrays and pandas Series for Y_train
            neighbor_labels = [Y_train.iloc[i] if hasattr(Y_train, 'iloc') else Y_train[i] for i in neighbor_indices]

            # Perform majority vote to get the predicted label
            most_common = Counter(neighbor_labels).most_common(1)
            predictions.append(most_common[0][0])
        return np.array(predictions)


classifier5_euclidean = KNN_Classifier(distance_metric='euclidean')
classifier5_manhattan = KNN_Classifier(distance_metric='manhattan')

print("KNN_Classifier class has been redefined and instances re-initialized.")